// Generated by CoffeeScript 1.3.3
(function() {
  var CAMERA, CloudCA, Clouds, GENERATION_LENGTH, Lerp, MAX_WEIGHT, P_ACT, P_EXT, P_HUM, RENDERER, SCENE, SMOOTH, START_TIME, WIND_SPEED, Z_POS, root, x, y, z, _i, _j, _k, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

  START_TIME = new Date().getTime();

  P_EXT = 0.1;

  P_ACT = 0.01;

  P_HUM = 0.1;

  WIND_SPEED = 5;

  GENERATION_LENGTH = 1000;

  SMOOTH = {
    X: 2,
    Y: 2,
    Z: 2
  };

  MAX_WEIGHT = 0;

  for (x = _i = _ref = -SMOOTH.X, _ref1 = SMOOTH.X; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _ref <= _ref1 ? ++_i : --_i) {
    for (y = _j = _ref2 = -SMOOTH.Y, _ref3 = SMOOTH.Y; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; y = _ref2 <= _ref3 ? ++_j : --_j) {
      for (z = _k = _ref4 = -SMOOTH.Z, _ref5 = SMOOTH.Z; _ref4 <= _ref5 ? _k <= _ref5 : _k >= _ref5; z = _ref4 <= _ref5 ? ++_k : --_k) {
        MAX_WEIGHT += Math.sqrt((x * x) + (y * y) + (z * z));
      }
    }
  }

  RENDERER = null;

  SCENE = null;

  CAMERA = null;

  Z_POS = 3000;

  Lerp = function(x, y, s) {
    return x * (1 - s) + (y * s);
  };

  Clouds = function() {
    var clouds, groupBack, groupFront, materials, positions, rotations, simulate;
    RENDERER = new THREE.WebGLRenderer({
      antialias: false
    });
    SCENE = new THREE.Scene();
    CAMERA = new THREE.PerspectiveCamera(45, $(window).innerWidth() / $(window).innerHeight(), 1, 2450);
    RENDERER.setSize($(window).innerWidth(), $(window).innerHeight());
    $('.clouds div').append(RENDERER.domElement);
    $(window).resize(function() {
      CAMERA.aspect = $(window).innerWidth() / $(window).innerHeight();
      CAMERA.updateProjectionMatrix();
      return RENDERER.setSize($(window).innerWidth(), $(window).innerHeight());
    });
    $(window).trigger('resize');
    CAMERA.position.y = 190;
    CAMERA.position.z = Z_POS;
    SCENE.add(CAMERA);
    materials = function() {
      var fog, fs, m, texture, u, vs, _l, _results;
      vs = $('#vs').text();
      fs = $('#fs').text();
      fog = new THREE.Fog(0x2F222F, -1000, 100000);
      _results = [];
      for (m = _l = 0; _l <= 1; m = ++_l) {
        texture = THREE.ImageUtils.loadTexture("images/cloud" + m + ".png");
        texture.magFilter = THREE.LinearMipMapLinearFilter;
        texture.minFilter = THREE.LinearMipMapLinearFilter;
        u = {
          'map': {
            type: 't',
            value: texture
          },
          'fogColor': {
            type: 'c',
            value: fog.color
          },
          'fogNear': {
            type: 'f',
            value: fog.near
          },
          'fogFar': {
            type: 'f',
            value: fog.far
          }
        };
        _results.push(new THREE.ShaderMaterial({
          uniforms: u,
          vertexShader: vs,
          fragmentShader: fs,
          depthWrite: false
        }));
      }
      return _results;
    };
    materials = materials();
    clouds = new CloudCA(64, 8, 8);
    groupFront = null;
    groupBack = null;
    positions = [];
    rotations = [];
    return (simulate = function() {
      var cloudDensity, i, planeBack, planeFront, scale, _l, _m, _n, _ref6, _ref7, _ref8;
      if (clouds.gen === 0) {
        groupFront = new THREE.Object3D();
        groupBack = new THREE.Object3D();
        SCENE.add(groupFront);
        SCENE.add(groupBack);
      }
      if (clouds.gen % GENERATION_LENGTH === 0) {
        cloudDensity = clouds.getGeneration();
      }
      i = 0;
      for (x = _l = 0, _ref6 = (clouds.x - 1) * clouds.interpolate; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; x = 0 <= _ref6 ? ++_l : --_l) {
        for (y = _m = 0, _ref7 = (clouds.y - 1) * clouds.interpolate; 0 <= _ref7 ? _m < _ref7 : _m > _ref7; y = 0 <= _ref7 ? ++_m : --_m) {
          for (z = _n = 0, _ref8 = (clouds.z - 1) * clouds.interpolate; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; z = 0 <= _ref8 ? ++_n : --_n) {
            if (clouds.gen === 0) {
              planeFront = new THREE.Mesh(new THREE.PlaneGeometry(64, 64), materials[0]);
              planeFront.position.x = 100000;
              planeBack = new THREE.Mesh(new THREE.PlaneGeometry(64, 64), materials[0]);
              planeBack.position.x = 100000;
              positions[i] = clouds.positions[x][y][z];
              rotations[i] = {
                initial: ((Math.random() * 2) - 1) * Math.PI,
                increment: ((Math.random() * 2) - 1) * Math.PI / 2000
              };
              groupFront.add(planeFront);
              groupBack.add(planeBack);
            }
            scale = Lerp(clouds.density.current[x][y][z], clouds.density.next[x][y][z], (clouds.gen % GENERATION_LENGTH) / GENERATION_LENGTH) * 20;
            if (scale !== 0) {
              planeFront = groupFront.children[i];
              planeBack = groupBack.children[i];
              if (scale < 0.1) {
                planeFront.material = materials[1];
                planeBack.material = materials[1];
              }
              planeFront.position = positions[i];
              planeBack.position = new THREE.Vector3(positions[i].x, positions[i].y, positions[i].z - Z_POS);
              planeFront.rotation.z = rotations[i].initial + (rotations[i].increment * clouds.gen);
              planeBack.rotation.z = rotations[i].initial + (rotations[i].increment * clouds.gen);
              planeFront.scale.x = planeFront.scale.y = scale;
              planeBack.scale.x = planeBack.scale.y = scale;
            }
            i += 1;
          }
        }
      }
      clouds.gen++;
      CAMERA.position.z = -(((new Date().getTime() - START_TIME) * 0.03) % Z_POS) + Z_POS;
      RENDERER.render(SCENE, CAMERA);
      return requestAnimFrame(simulate);
    })();
  };

  CloudCA = (function() {
    var createPositions, extinction, getDensity, growth, logic, neighboursAct, toGrid, trilinear, wind;

    function CloudCA(x, y, z, interpolate, gen) {
      var i;
      this.x = x;
      this.y = y;
      this.z = z;
      this.interpolate = interpolate != null ? interpolate : 1;
      this.gen = gen != null ? gen : 0;
      this.size = this.x * this.y * this.z;
      this.positions = createPositions.call(this);
      this._ = {
        gen: {
          hum: ((function() {
            var _l, _ref6, _results;
            _results = [];
            for (i = _l = 0, _ref6 = this.size; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; i = 0 <= _ref6 ? ++_l : --_l) {
              _results.push(Math.random() > 0.5 ? '1' : '0');
            }
            return _results;
          }).call(this)).join(''),
          act: ((function() {
            var _l, _ref6, _results;
            _results = [];
            for (i = _l = 0, _ref6 = this.size; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; i = 0 <= _ref6 ? ++_l : --_l) {
              _results.push(Math.random() > 0.5 ? '1' : '0');
            }
            return _results;
          }).call(this)).join(''),
          cld: ((function() {
            var _l, _ref6, _results;
            _results = [];
            for (i = _l = 0, _ref6 = this.size; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; i = 0 <= _ref6 ? ++_l : --_l) {
              _results.push('0');
            }
            return _results;
          }).call(this)).join('')
        }
      };
      this._.clouds = toGrid.call(this, (function(x, y, z) {
        return +this._.gen.cld[x * this.x + y * this.y + z];
      }));
      this.density = {
        current: null,
        next: toGrid.call(this, (function(x, y, z) {
          return getDensity(this._.clouds, x, y, z);
        }))
      };
      this.getGeneration();
    }

    createPositions = function() {
      var d, dim, max, min, pos, rand, _l, _ref6, _results;
      min = {
        x: -500,
        y: 50,
        z: 0
      };
      max = {
        x: 500,
        y: 200,
        z: 3000
      };
      d = {
        x: (max.x - min.x) / ((this.x - 1) * this.interpolate),
        y: (max.y - min.y) / ((this.y - 1) * this.interpolate),
        z: (max.z - min.z) / ((this.z - 1) * this.interpolate)
      };
      _results = [];
      for (x = _l = 0, _ref6 = (this.x - 1) * this.interpolate; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; x = 0 <= _ref6 ? ++_l : --_l) {
        _results.push((function() {
          var _m, _ref7, _results1;
          _results1 = [];
          for (y = _m = 0, _ref7 = (this.y - 1) * this.interpolate; 0 <= _ref7 ? _m < _ref7 : _m > _ref7; y = 0 <= _ref7 ? ++_m : --_m) {
            _results1.push((function() {
              var _len, _n, _o, _ref8, _ref9, _results2;
              _results2 = [];
              for (z = _n = 0, _ref8 = (this.z - 1) * this.interpolate; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; z = 0 <= _ref8 ? ++_n : --_n) {
                rand = {};
                _ref9 = ['x', 'y', 'z'];
                for (_o = 0, _len = _ref9.length; _o < _len; _o++) {
                  dim = _ref9[_o];
                  rand[dim] = (Math.random() * d[dim]) - (d[dim] / 2);
                }
                pos = {
                  x: min.x + (d.x * (x + 0.5)) + rand.x,
                  y: min.y + (d.y * (y + 0.5)) + rand.y,
                  z: min.z + (d.z * (z + 0.5)) + rand.z
                };
                _results2.push(new THREE.Vector3(pos.x, pos.y, pos.z));
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    logic = {
      and: function(str1, str2, res) {
        var i, _l, _ref6;
        if (res == null) {
          res = '';
        }
        for (i = _l = 0, _ref6 = str1.length; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; i = 0 <= _ref6 ? ++_l : --_l) {
          res += "" + (str1[i] & str2[i]);
        }
        return res;
      },
      or: function(str1, str2, res) {
        var i, _l, _ref6;
        if (res == null) {
          res = '';
        }
        for (i = _l = 0, _ref6 = str1.length; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; i = 0 <= _ref6 ? ++_l : --_l) {
          res += "" + (str1[i] | str2[i]);
        }
        return res;
      },
      not: function(str, res) {
        var i, _l, _ref6;
        if (res == null) {
          res = '';
        }
        for (i = _l = 0, _ref6 = str.length; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; i = 0 <= _ref6 ? ++_l : --_l) {
          res += str[i] === '0' ? '1' : '0';
        }
        return res;
      }
    };

    toGrid = function(func) {
      var _l, _ref6, _results;
      _results = [];
      for (x = _l = 0, _ref6 = this.x; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; x = 0 <= _ref6 ? ++_l : --_l) {
        _results.push((function() {
          var _m, _ref7, _results1;
          _results1 = [];
          for (y = _m = 0, _ref7 = this.y; 0 <= _ref7 ? _m < _ref7 : _m > _ref7; y = 0 <= _ref7 ? ++_m : --_m) {
            _results1.push((function() {
              var _n, _ref8, _results2;
              _results2 = [];
              for (z = _n = 0, _ref8 = this.z; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; z = 0 <= _ref8 ? ++_n : --_n) {
                _results2.push(func.call(this, x, y, z));
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    trilinear = function(grid) {
      var c0, c00, c01, c1, c10, c11, interpolated, nextX, nextY, nextZ, origX, origY, origZ, prevX, prevY, prevZ, xd, yd, zd, _base, _l, _m, _n, _o, _p, _q, _ref10, _ref11, _ref12, _ref13, _ref6, _ref7, _ref8, _ref9;
      interpolated = [];
      for (x = _l = 0, _ref6 = (this.x - 1) * this.interpolate; 0 <= _ref6 ? _l <= _ref6 : _l >= _ref6; x = 0 <= _ref6 ? ++_l : --_l) {
        if ((_ref7 = interpolated[x]) == null) {
          interpolated[x] = [];
        }
        for (y = _m = 0, _ref8 = (this.y - 1) * this.interpolate; 0 <= _ref8 ? _m <= _ref8 : _m >= _ref8; y = 0 <= _ref8 ? ++_m : --_m) {
          if ((_ref9 = (_base = interpolated[x])[y]) == null) {
            _base[y] = [];
          }
          for (z = _n = 0, _ref10 = (this.z - 1) * this.interpolate; 0 <= _ref10 ? _n <= _ref10 : _n >= _ref10; z = 0 <= _ref10 ? ++_n : --_n) {
            origX = Math.floor(x / this.interpolate);
            origY = Math.floor(y / this.interpolate);
            origZ = Math.floor(z / this.interpolate);
            if (x % this.interpolate === 0 && y % this.interpolate === 0 && z % this.interpolate === 0) {
              interpolated[x][y][z] = grid[origX][origY][origZ];
            }
          }
        }
      }
      for (x = _o = 0, _ref11 = (this.x - 1) * this.interpolate; 0 <= _ref11 ? _o <= _ref11 : _o >= _ref11; x = 0 <= _ref11 ? ++_o : --_o) {
        for (y = _p = 0, _ref12 = (this.y - 1) * this.interpolate; 0 <= _ref12 ? _p <= _ref12 : _p >= _ref12; y = 0 <= _ref12 ? ++_p : --_p) {
          for (z = _q = 0, _ref13 = (this.z - 1) * this.interpolate; 0 <= _ref13 ? _q <= _ref13 : _q >= _ref13; z = 0 <= _ref13 ? ++_q : --_q) {
            if (interpolated[x][y][z] == null) {
              prevX = Math.floor(x / this.interpolate);
              prevY = Math.floor(y / this.interpolate);
              prevZ = Math.floor(z / this.interpolate);
              nextX = Math.min(prevX + 1, this.x - 1);
              nextY = Math.min(prevY + 1, this.y - 1);
              nextZ = Math.min(prevZ + 1, this.z - 1);
              xd = (x - (prevX * this.interpolate)) / ((nextX * this.interpolate) - (prevX * this.interpolate));
              yd = (y - (prevY * this.interpolate)) / ((nextY * this.interpolate) - (prevY * this.interpolate));
              zd = (z - (prevZ * this.interpolate)) / ((nextZ * this.interpolate) - (prevZ * this.interpolate));
              c00 = !isNaN(xd) ? Lerp(grid[prevX][prevY][prevZ], grid[nextX][prevY][prevZ], xd) : grid[prevX][prevY][prevZ];
              c10 = !isNaN(xd) ? Lerp(grid[prevX][nextY][prevZ], grid[nextX][nextY][prevZ], xd) : grid[prevX][nextY][prevZ];
              c01 = !isNaN(xd) ? Lerp(grid[prevX][prevY][nextZ], grid[nextX][prevY][nextZ], xd) : grid[prevX][prevY][nextZ];
              c11 = !isNaN(xd) ? Lerp(grid[prevX][nextY][nextZ], grid[nextX][nextY][nextZ], xd) : grid[prevX][nextY][nextZ];
              c0 = !isNaN(yd) ? Lerp(c00, c10, yd) : c00;
              c1 = !isNaN(yd) ? Lerp(c01, c11, yd) : c01;
              interpolated[x][y][z] = !isNaN(zd) ? Lerp(c0, c1, zd) : c0;
            }
          }
        }
      }
      return interpolated;
    };

    growth = function(gen, nAct) {
      var act, actGrid, cld, hum, newAct, newCld, newHum;
      if (nAct == null) {
        nAct = '';
      }
      hum = gen.hum, act = gen.act, cld = gen.cld;
      actGrid = toGrid.call(this, (function(x, y, z) {
        return +act[x * this.x + y * this.y + z];
      }));
      nAct = neighboursAct.call(this, actGrid);
      newHum = logic.and(hum, logic.not(act));
      newAct = logic.and(newHum, nAct);
      newCld = logic.or(cld, act);
      return {
        hum: newHum,
        act: newAct,
        cld: newCld
      };
    };

    neighboursAct = function(grid, str) {
      var neighbourAct, _l, _m, _n, _ref6, _ref7, _ref8;
      if (str == null) {
        str = '';
      }
      neighbourAct = function(grid, x, y, z) {
        var _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref6, _ref7, _ref8, _ref9;
        return ((_ref6 = grid[x + 1]) != null ? (_ref7 = _ref6[y]) != null ? _ref7[z] : void 0 : void 0) || ((_ref8 = grid[x]) != null ? (_ref9 = _ref8[y + 1]) != null ? _ref9[z] : void 0 : void 0) || ((_ref10 = grid[x]) != null ? (_ref11 = _ref10[y]) != null ? _ref11[z + 1] : void 0 : void 0) || ((_ref12 = grid[x - 1]) != null ? (_ref13 = _ref12[y]) != null ? _ref13[z] : void 0 : void 0) || ((_ref14 = grid[x]) != null ? (_ref15 = _ref14[y - 1]) != null ? _ref15[z] : void 0 : void 0) || ((_ref16 = grid[x]) != null ? (_ref17 = _ref16[y]) != null ? _ref17[z - 1] : void 0 : void 0) || ((_ref18 = grid[x - 2]) != null ? (_ref19 = _ref18[y]) != null ? _ref19[z] : void 0 : void 0) || ((_ref20 = grid[x + 2]) != null ? (_ref21 = _ref20[y]) != null ? _ref21[z] : void 0 : void 0) || ((_ref22 = grid[x]) != null ? (_ref23 = _ref22[y - 2]) != null ? _ref23[z] : void 0 : void 0) || ((_ref24 = grid[x]) != null ? (_ref25 = _ref24[y + 2]) != null ? _ref25[z] : void 0 : void 0) || ((_ref26 = grid[x]) != null ? (_ref27 = _ref26[y]) != null ? _ref27[z - 2] : void 0 : void 0);
      };
      for (x = _l = 0, _ref6 = this.x; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; x = 0 <= _ref6 ? ++_l : --_l) {
        for (y = _m = 0, _ref7 = this.y; 0 <= _ref7 ? _m < _ref7 : _m > _ref7; y = 0 <= _ref7 ? ++_m : --_m) {
          for (z = _n = 0, _ref8 = this.z; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; z = 0 <= _ref8 ? ++_n : --_n) {
            str += neighbourAct(grid, x, y, z) ? '1' : '0';
          }
        }
      }
      return str;
    };

    extinction = function(gen, randHum, randAct, randCld) {
      var act, cld, hum, i, newAct, newCld, newHum, _l, _m, _n, _ref6, _ref7, _ref8;
      if (randHum == null) {
        randHum = '';
      }
      if (randAct == null) {
        randAct = '';
      }
      if (randCld == null) {
        randCld = '';
      }
      hum = gen.hum, act = gen.act, cld = gen.cld;
      for (i = _l = 0, _ref6 = this.size; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; i = 0 <= _ref6 ? ++_l : --_l) {
        randHum += Math.random() < P_HUM ? '1' : '0';
      }
      for (i = _m = 0, _ref7 = this.size; 0 <= _ref7 ? _m < _ref7 : _m > _ref7; i = 0 <= _ref7 ? ++_m : --_m) {
        randAct += Math.random() < P_ACT ? '1' : '0';
      }
      for (i = _n = 0, _ref8 = this.size; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; i = 0 <= _ref8 ? ++_n : --_n) {
        randCld += Math.random() > P_EXT ? '1' : '0';
      }
      newHum = logic.or(hum, randHum);
      newAct = logic.or(act, randAct);
      newCld = logic.and(cld, randCld);
      return {
        hum: newHum,
        act: newAct,
        cld: newCld
      };
    };

    wind = function(gen, humStr, actStr, cldStr) {
      var act, cld, hum, newAct, newCld, newHum, windChange, windSpeed, _l, _m, _n, _o, _p, _q, _ref10, _ref11, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      if (humStr == null) {
        humStr = '';
      }
      if (actStr == null) {
        actStr = '';
      }
      if (cldStr == null) {
        cldStr = '';
      }
      windSpeed = function(z) {
        return Math.floor(z * (WIND_SPEED / _this.z));
      };
      hum = gen.hum, act = gen.act, cld = gen.cld;
      hum = toGrid.call(this, (function(x, y, z) {
        return +hum[x * this.x + y * this.y + z];
      }));
      act = toGrid.call(this, (function(x, y, z) {
        return +act[x * this.x + y * this.y + z];
      }));
      cld = toGrid.call(this, (function(x, y, z) {
        return +cld[x * this.x + y * this.y + z];
      }));
      newHum = toGrid.call(this, (function() {
        return {};
      }));
      newAct = toGrid.call(this, (function() {
        return {};
      }));
      newCld = toGrid.call(this, (function() {
        return {};
      }));
      for (x = _l = 0, _ref6 = this.x; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; x = 0 <= _ref6 ? ++_l : --_l) {
        for (y = _m = 0, _ref7 = this.y; 0 <= _ref7 ? _m < _ref7 : _m > _ref7; y = 0 <= _ref7 ? ++_m : --_m) {
          for (z = _n = 0, _ref8 = this.z; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; z = 0 <= _ref8 ? ++_n : --_n) {
            windChange = windSpeed(z);
            newHum[x][y][z] = hum[x - windChange] != null ? hum[x - windChange][y][z] : 0;
            newAct[x][y][z] = act[x - windChange] != null ? act[x - windChange][y][z] : 0;
            newCld[x][y][z] = cld[x - windChange] != null ? cld[x - windChange][y][z] : 0;
          }
        }
      }
      for (x = _o = 0, _ref9 = this.x; 0 <= _ref9 ? _o < _ref9 : _o > _ref9; x = 0 <= _ref9 ? ++_o : --_o) {
        for (y = _p = 0, _ref10 = this.y; 0 <= _ref10 ? _p < _ref10 : _p > _ref10; y = 0 <= _ref10 ? ++_p : --_p) {
          for (z = _q = 0, _ref11 = this.z; 0 <= _ref11 ? _q < _ref11 : _q > _ref11; z = 0 <= _ref11 ? ++_q : --_q) {
            humStr += newHum[x][y][z];
            actStr += newAct[x][y][z];
            cldStr += newCld[x][y][z];
          }
        }
      }
      return {
        hum: humStr,
        act: actStr,
        cld: cldStr
      };
    };

    getDensity = function(clouds, x, y, z) {
      var density, exists, weight, xs, ys, zs, _l, _m, _n, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref6, _ref7, _ref8, _ref9;
      weight = function(dx, dy, dz) {
        return Math.sqrt((dx * dx) + (dy * dy) + (dz * dz));
      };
      density = 0;
      if (((_ref6 = clouds[x]) != null ? (_ref7 = _ref6[y]) != null ? _ref7[z] : void 0 : void 0) === 1) {
        for (xs = _l = _ref8 = x - SMOOTH.X, _ref9 = x + SMOOTH.X; _ref8 <= _ref9 ? _l <= _ref9 : _l >= _ref9; xs = _ref8 <= _ref9 ? ++_l : --_l) {
          for (ys = _m = _ref10 = y - SMOOTH.Y, _ref11 = y + SMOOTH.Y; _ref10 <= _ref11 ? _m <= _ref11 : _m >= _ref11; ys = _ref10 <= _ref11 ? ++_m : --_m) {
            for (zs = _n = _ref12 = z - SMOOTH.Z, _ref13 = z + SMOOTH.Z; _ref12 <= _ref13 ? _n <= _ref13 : _n >= _ref13; zs = _ref12 <= _ref13 ? ++_n : --_n) {
              exists = ((_ref14 = clouds[xs]) != null ? (_ref15 = _ref14[ys]) != null ? _ref15[zs] : void 0 : void 0) != null;
              density += (exists && clouds[xs][ys][zs] === 1 ? weight(xs - x, ys - x, zs - x) : 0);
            }
          }
        }
      }
      if (density !== 0) {
        density /= MAX_WEIGHT;
        density /= (2 * SMOOTH.X + 1) * (2 * SMOOTH.Y + 1) * (2 * SMOOTH.Z + 1);
      } else {
        density = density;
      }
      return density;
    };

    CloudCA.prototype.getGeneration = function() {
      this._.gen = growth.call(this, this._.gen);
      this._.gen = extinction.call(this, this._.gen);
      this._.gen = wind.call(this, this._.gen);
      this._.clouds = toGrid.call(this, (function(x, y, z) {
        return +this._.gen.cld[x * this.x + y * this.y + z];
      }));
      this.density = {
        current: this.density.next,
        next: toGrid.call(this, (function(x, y, z) {
          return getDensity(this._.clouds, x, y, z);
        }))
      };
      if (this.interpolate !== 1) {
        this.density.next = trilinear.call(this, this.density.next);
      }
      return this.density;
    };

    return CloudCA;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Clouds = Clouds;

}).call(this);
